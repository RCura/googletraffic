hw_vec
hw_vec[-1]
## Don't consider maximum; we initialize with maximum
hw_vec <- hw_vec[-1]
## Set initial height/width to use
hw_use <- height_width_max
## Set initial height/width to use
hw_use <- height_width_max
## Check initial rows
grid_param_df <- gt_make_grid(polygon   = polygon,
height    = height_width_max,
width     = height_width_max,
zoom      = zoom,
reduce_hw = 0)
n_grid_initial <- nrow(grid_param_df)
n_grid_initial
## Set min to check
height_width_min = min(c(250, round(height_width_max/2)))
## Height/widths to try
hw_vec <- seq(from = height_width_min,
to = height_width_max,
by = (height_width_max - height_width_min)/4) %>%
ceiling() %>%
rev()
## Don't consider maximum; we initialize with maximum
hw_vec <- hw_vec[-1]
## Set initial height/width to use
hw_use <- height_width_max
## Check initial rows
grid_param_df <- gt_make_grid(polygon   = polygon,
height    = height_width_max,
width     = height_width_max,
zoom      = zoom,
reduce_hw = 0)
n_grid_initial <- nrow(grid_param_df)
## Check if can use smaller height/width
for(hw in hw_vec){
grid_param_df <- gt_make_grid(polygon   = polygon,
height    = hw,
width     = hw,
zoom      = zoom,
reduce_hw = 0)
# If initial number of grids can be achieved with using a small height/width,
# then use the smaller height/width
if(nrow(grid_param_df) == n_grid_initial) hw_use <- hw
}
hw_use
#### Make height/width
height <- 3000
width <- 3000
# If height and width are both specified, use those; if not, optimize height/width up to height_width_max
if(!(!is.null(height) & !is.null(width))){
## Set min to check
height_width_min = min(c(250, round(height_width_max/2)))
## Height/widths to try
hw_vec <- seq(from = height_width_min,
to = height_width_max,
by = (height_width_max - height_width_min)/4) %>%
ceiling() %>%
rev()
## Don't consider maximum; we initialize with maximum
hw_vec <- hw_vec[-1]
## Set initial height/width to use
hw_use <- height_width_max
## Check initial rows
grid_param_df <- gt_make_grid(polygon   = polygon,
height    = height_width_max,
width     = height_width_max,
zoom      = zoom,
reduce_hw = 0)
n_grid_initial <- nrow(grid_param_df)
## Check if can use smaller height/width
for(hw in hw_vec){
grid_param_df <- gt_make_grid(polygon   = polygon,
height    = hw,
width     = hw,
zoom      = zoom,
reduce_hw = 0)
# If initial number of grids can be achieved with using a small height/width,
# then use the smaller height/width
if(nrow(grid_param_df) == n_grid_initial) hw_use <- hw
}
height <- hw_use
width  <- hw_use
}
height
#### Make height/width
height <- NULL
width <- NULL
height_width_max <- 2000
# If height and width are both specified, use those; if not, optimize height/width up to height_width_max
if(!(!is.null(height) & !is.null(width))){
## Set min to check
height_width_min = min(c(250, round(height_width_max/2)))
## Height/widths to try
hw_vec <- seq(from = height_width_min,
to = height_width_max,
by = (height_width_max - height_width_min)/4) %>%
ceiling() %>%
rev()
## Don't consider maximum; we initialize with maximum
hw_vec <- hw_vec[-1]
## Set initial height/width to use
hw_use <- height_width_max
## Check initial rows
grid_param_df <- gt_make_grid(polygon   = polygon,
height    = height_width_max,
width     = height_width_max,
zoom      = zoom,
reduce_hw = 0)
n_grid_initial <- nrow(grid_param_df)
## Check if can use smaller height/width
for(hw in hw_vec){
grid_param_df <- gt_make_grid(polygon   = polygon,
height    = hw,
width     = hw,
zoom      = zoom,
reduce_hw = 0)
# If initial number of grids can be achieved with using a small height/width,
# then use the smaller height/width
if(nrow(grid_param_df) == n_grid_initial) hw_use <- hw
}
height <- hw_use
width  <- hw_use
}
height
width
# Make Grid
#' Creates grid to query Google Traffic
#'
#' Querying too large of a location may be unfeasible; consequently, it may be necessary to query multiple smaller locations to cover a large location. Based on the location to be queried and the height, width and zoom parameters, determines the points that should be queried.
#'
#' @param polygon Polygon (`sf` object or `SpatialPolygonsDataframe`) in WGS84 CRS the defines region to be queried.
#' @param zoom Zoom level; integer from 0 to 20. For more information, see [here](https://wiki.openstreetmap.org/wiki/Zoom_levels)
#' @param height_width_max Maximum pixel height and width to check using (pixel length depends on zoom). If the same number of grids can be made with a smaller height/width, the function will use a smaller height/width. If height and width are specified, that height and width will be used and height_width_max will be ignored. (Default: 2000)
#' @param height Pixel height (pixel length depends on zoom). Enter a `height` to manually specify the height; otherwise, a height of `height_width_max` or smaller will be used.
#' @param width Pixel width (pixel length depends on zoom). Enter a `width` to manually specify the width; otherwise, a width of `height_width_max` or smaller will be used.
#' @param reduce_hw Number of pixels to reduce height/width by. Doing so creates some overlap between tiles to ensure there is not blank space between tiles (default = 10 pixels).
#'
#' @return Returns a dataframe with the locations to query and parameters.
#'
#' @examples
#' ## Make polygon
#' poly_sf <- c(xmin = -74.02426,
#'              xmax = -73.91048,
#'              ymin = 40.70042,
#'              ymax = 40.87858) %>%
#'   sf::st_bbox() %>%
#'   sf::st_as_sfc() %>%
#'   sf::st_as_sf()
#'
#' sf::st_crs(poly_sf) <- 4326
#'
#' ## Make grid using polygon
#' grid_sf <- gt_make_grid(polygon = poly_sf,
#'                         height  = 2000,
#'                         width   = 2000,
#'                         zoom    = 16)
#'
#' @export
gt_make_grid <- function(polygon,
zoom,
height_width_max = 2000,
height = NULL,
width = NULL,
reduce_hw = 10){
## Polygon should be sf object
if(class(polygon)[1] %in% "SpatialPolygonsDataFrame"){
polygon <- polygon %>% sf::st_as_sf()
}
## If polygon is more than one row, make one polygon
if(nrow(polygon) > 1){
polygon$id <- 1
polygon <- polygon %>%
dplyr::group_by(id) %>%
dplyr::summarize(geometry = st_union(geometry))
}
#### Checks
if(is.null(height) & !is.null(width)){
stop('"width" specified but not "height"; if specify "width", must also specify "height." If don\'t specify either "height" or "width", the function will choose a "height" and "width" based on the extent of the polygon.')
}
if(!is.null(height) & is.null(width)){
stop('"height" specified but not "width"; if specify "height", must also specify "width" If don\'t specify either "height" or "width", the function will choose a "height" and "width" based on the extent of the polygon.')
}
if(!is.null(height) & !is.null(width) & !is.null(height_width_max)){
warning('"height_width_max" ignored; if "height", "width", and "height_width_max" are all specified, "height_width_max" will be ignored.')
}
#### Make height/width
# If height and width are both specified, use those;
# if not, optimize height/width up to height_width_max
if(!(!is.null(height) & !is.null(width))){
## Set min to check
height_width_min = min(c(250, round(height_width_max/2)))
## Height/widths to try
hw_vec <- seq(from = height_width_min,
to = height_width_max,
by = (height_width_max - height_width_min)/4) %>%
ceiling() %>%
rev()
## Don't consider maximum; we initialize with maximum
hw_vec <- hw_vec[-1]
## Set initial height/width to use
hw_use <- height_width_max
## Check initial rows
grid_param_df <- gt_make_grid(polygon   = polygon,
height    = height_width_max,
width     = height_width_max,
zoom      = zoom,
reduce_hw = 0)
n_grid_initial <- nrow(grid_param_df)
## Check if can use smaller height/width
for(hw in hw_vec){
grid_param_df <- gt_make_grid(polygon   = polygon,
height    = hw,
width     = hw,
zoom      = zoom,
reduce_hw = 0)
# If initial number of grids can be achieved with using a small height/width,
# then use the smaller height/width
if(nrow(grid_param_df) == n_grid_initial) hw_use <- hw
}
height <- hw_use
width  <- hw_use
}
## Reduce height/width
# Extents may not perfectly connect. Reducing the height and width aims to create
# some overlap in the extents, so all the tiles will connect.
height_use <- height - reduce_hw
width_use  <- width  - reduce_hw
## Decimal degree distance of pixel
# Use most extreme latitude location
most_extreme_lat_point <- sf::st_coordinates(polygon) %>%
as.data.frame() %>%
dplyr::mutate(Y_abs = abs(Y)) %>%
dplyr::arrange(-Y_abs) %>%
head(1)
most_extreme_lat_ext <- gt_make_extent(latitude = most_extreme_lat_point$Y,
longitude = most_extreme_lat_point$X,
height = height,
width = width,
zoom = zoom)
pixel_dist_deg <- min(
(most_extreme_lat_ext@xmax - most_extreme_lat_ext@xmin) / width,
(most_extreme_lat_ext@ymax - most_extreme_lat_ext@ymin) / height
)
x_degree <- (most_extreme_lat_ext@xmax - most_extreme_lat_ext@xmin) / width
y_degree <- (most_extreme_lat_ext@ymax - most_extreme_lat_ext@ymin) / height
## Make raster and convert to polygon
poly_ext <- raster::extent(polygon)
r <- raster::raster(ext = poly_ext, res=c(width_use*x_degree,
height_use*y_degree))
r <- raster::extend(r, c(1,1)) #Expand by one cell, to ensure covers all study area
p <- r %>% raster::rasterToPolygons() %>% sf::st_as_sf()
## Only keep polygons that intersect with original polygon
p_inter_tf <- sf::st_intersects(p, polygon, sparse=F) %>% as.vector()
p_inter <- p[p_inter_tf,]
## Grab points
points_df <- p_inter %>%
sf::st_centroid() %>%
sf::st_coordinates() %>%
as.data.frame() %>%
dplyr::rename(longitude = X,
latitude = Y) %>%
dplyr::mutate(id = 1:n(),
height = height,
width = width,
zoom = zoom)
geom <- lapply(1:nrow(points_df), function(i){
param <- points_df[i,]
ext <- gt_make_extent(param$latitude,
param$longitude,
param$height,
param$width,
param$zoom)
ext %>%
sf::st_bbox() %>%
sf::st_as_sfc() %>%
sf::st_as_sf(crs = CRS("+init=epsg:4326"))
#as(ext, "SpatialPolygons") %>% st_as_sf()
}) %>%
dplyr::bind_rows()
points_sf <- sf::st_sf(points_df, geometry = geom$x)
return(points_sf)
}
remove.packages("googletraffic")
roxygen2::roxygenise("~/Documents/Github/googletraffic")
roxygen2::roxygenise("~/Documents/Github/googletraffic")
# Load .png as Traffic Raster
#' Converts png to raster
#'
#' Converts PNG to raster and translates color values to traffic values
#'
#' @param filename Filename/path of png file
#' @param location Vector of latitude and longitude used to create png file using `gt_make_png()`
#' @param height Height (in pixels; pixel length depends on zoom) used to create png file using `gt_make_png()`
#' @param width Width (in pixels; pixel length depends on zoom) used to create png file using `gt_make_png()`
#' @param zoom Zoom used to create png file using `gt_make_png()`
#'
#' @return Returns a raster where each pixel represents traffic level (1 = no traffic, 2 = medium traffic, 3 = traffic delays, 4 = heavy traffic)
#'
#' @examples
#' \dontrun{
#' ## Make png
#' gt_make_png(location     = c(40.712778, -74.006111),
#'             height       = 1000,
#'             width        = 1000,
#'             zoom         = 16,
#'             out_filename = "google_traffic.png",
#'             google_key   = "GOOGLE-KEY-HERE")
#'
#' ## Load png as traffic raster
#' r <- gt_load_png_as_traffic_raster(filename = "google_traffic.png",
#'                                    location = c(40.712778, -74.006111),
#'                                    height   = 1000,
#'                                    width    = 1000,
#'                                    zoom     = 16)
#'}
#'
#' @export
gt_load_png_as_traffic_raster <- function(filename,
location,
height,
width,
zoom){
#### Set latitude and longitude
latitude  <- location[1]
longitude <- location[2]
#### Load
r   <- raster::raster(filename,1)
img <- png::readPNG(filename)
#### Assign traffic colors
## Image to hex
rimg <- raster::as.raster(img)
colors_df <- rimg %>%
table() %>%
as.data.frame() %>%
dplyr::rename(hex = ".")
colors_df$hex <- colors_df$hex %>%
as.character()
## Assign traffic colors based on hsl
hsl_df <- colors_df$hex %>%
plotwidgets::col2hsl() %>%
t() %>%
as.data.frame()
colors_df <- dplyr::bind_cols(colors_df, hsl_df)
colors_df <- colors_df %>%
dplyr::mutate(color = case_when(#((H == 0) & (S < 0.2)) ~ "background",
((H == 0) & (S >= 0.28) & (S < 0.7) & (L >= 0.3) & (L <= 0.42)) ~ "dark-red",
H > 0 & H <= 5 & L <= 0.65 ~ "red", # L <= 0.80
H >= 20 & H <= 28 & L <= 0.80 ~ "orange", # L <= 0.85
H >= 120 & H <= 135 & L <= 0.80 ~ "green"))
## Apply traffic colors to raster
colors_unique <- colors_df$color %>% unique()
colors_unique <- colors_unique[!is.na(colors_unique)]
colors_unique <- colors_unique[!(colors_unique %in% "background")]
rimg <- matrix(rimg) #%>% raster::t() #%>% base::t()
for(color_i in colors_unique){
rimg[rimg %in% colors_df$hex[colors_df$color %in% color_i]] <- color_i
}
r[] <- NA
r[rimg %in% "green"]    <- 1
r[rimg %in% "orange"]   <- 2
r[rimg %in% "red"]      <- 3
r[rimg %in% "dark-red"] <- 4
## Spatially define raster
ext_4326 <- gt_make_extent(latitude = latitude,
longitude = longitude,
height = height,
width = width,
zoom = zoom)
# Project extent to 3857
ext_3857 <- ext_4326 %>%
sf::st_bbox() %>%
sf::st_as_sfc()
sf::st_crs(ext_3857) <- 4326
ext_3857 <- ext_3857 %>%
sf::st_transform(3857) %>%
sf::st_bbox() %>%
raster::extent()
raster::extent(r) <- ext_3857
raster::crs(r) <- sp::CRS("+init=epsg:3857")
## Convert to EPSG:4326
r <- raster::projectRaster(r, crs = CRS("+init=epsg:4326"), method = "ngb")
return(r)
}
gt_load_png_as_traffic_raster()
# Load .png as Traffic Raster
#' Converts png to raster
#'
#' Converts PNG to raster and translates color values to traffic values
#'
#' @param filename Filename/path of png file
#' @param location Vector of latitude and longitude used to create png file using `gt_make_png()`
#' @param height Height (in pixels; pixel length depends on zoom) used to create png file using `gt_make_png()`
#' @param width Width (in pixels; pixel length depends on zoom) used to create png file using `gt_make_png()`
#' @param zoom Zoom used to create png file using `gt_make_png()`
#'
#' @return Returns a raster where each pixel represents traffic level (1 = no traffic, 2 = medium traffic, 3 = traffic delays, 4 = heavy traffic)
#'
#' @examples
#' \dontrun{
#' ## Make png
#' gt_make_png(location     = c(40.712778, -74.006111),
#'             height       = 1000,
#'             width        = 1000,
#'             zoom         = 16,
#'             out_filename = "google_traffic.png",
#'             google_key   = "GOOGLE-KEY-HERE")
#'
#' ## Load png as traffic raster
#' r <- gt_load_png_as_traffic_raster(filename = "google_traffic.png",
#'                                    location = c(40.712778, -74.006111),
#'                                    height   = 1000,
#'                                    width    = 1000,
#'                                    zoom     = 16)
#'}
#'
#' @export
gt_load_png_as_traffic_raster <- function(filename,
location,
height,
width,
zoom){
#### Set latitude and longitude
latitude  <- location[1]
longitude <- location[2]
#### Load
r   <- raster::raster(filename,1)
img <- png::readPNG(filename)
#### Assign traffic colors
## Image to hex
rimg <- raster::as.raster(img)
colors_df <- rimg %>%
table() %>%
as.data.frame() %>%
dplyr::rename(hex = ".")
colors_df$hex <- colors_df$hex %>%
as.character()
## Assign traffic colors based on hsl
hsl_df <- colors_df$hex %>%
plotwidgets::col2hsl() %>%
t() %>%
as.data.frame()
colors_df <- dplyr::bind_cols(colors_df, hsl_df)
colors_df <- colors_df %>%
dplyr::mutate(color = case_when(#((H == 0) & (S < 0.2)) ~ "background",
((H == 0) & (S >= 0.28) & (S < 0.7) & (L >= 0.3) & (L <= 0.42)) ~ "dark-red",
H > 0 & H <= 5 & L <= 0.65 ~ "red", # L <= 0.80
H >= 20 & H <= 28 & L <= 0.80 ~ "orange", # L <= 0.85
H >= 120 & H <= 135 & L <= 0.80 ~ "green"))
## Apply traffic colors to raster
colors_unique <- colors_df$color %>% unique()
colors_unique <- colors_unique[!is.na(colors_unique)]
colors_unique <- colors_unique[!(colors_unique %in% "background")]
rimg <- matrix(rimg) #%>% raster::t() #%>% base::t()
for(color_i in colors_unique){
rimg[rimg %in% colors_df$hex[colors_df$color %in% color_i]] <- color_i
}
r[] <- NA
r[rimg %in% "green"]    <- 1
r[rimg %in% "orange"]   <- 2
r[rimg %in% "red"]      <- 3
r[rimg %in% "dark-red"] <- 4
## Spatially define raster
ext_4326 <- gt_make_extent(latitude = latitude,
longitude = longitude,
height = height,
width = width,
zoom = zoom)
# Project extent to 3857
ext_3857 <- ext_4326 %>%
sf::st_bbox() %>%
sf::st_as_sfc()
sf::st_crs(ext_3857) <- 4326
ext_3857 <- ext_3857 %>%
sf::st_transform(3857) %>%
sf::st_bbox() %>%
raster::extent()
raster::extent(r) <- ext_3857
raster::crs(r) <- sp::CRS("+init=epsg:3857")
## Convert to EPSG:4326
r <- raster::projectRaster(r, crs = CRS("+init=epsg:4326"), method = "ngb")
return(r)
}
roxygen2::roxygenise("~/Documents/Github/googletraffic")
# install.packages("devtools")
devtools::install_github("dime-worldbank/googletraffic")
roxygen2::roxygenise("~/Documents/Github/googletraffic")
setwd("~/Documents/Github/googletraffic")
usethis::use_pkgdown()
library(googletraffic)
## Load additional packages for working with and visualizing data
library(leaflet)
library(leaflet.extras)
library(leaflet.providers)
library(scales)
library(mapview)
library(raster)
library(tidyverse)
api_keys_df <- read_csv("~/Dropbox/World Bank/Webscraping/Files for Server/api_keys.csv")
google_key <- api_keys_df %>%
dplyr::filter(Service == "Google Directions API",
Account == "ramarty@email.wm.edu") %>%
pull(Key)
## Grab polygon of Manhattan
us_sp <- getData('GADM', country='USA', level=2)
ny_sp <- us_sp[us_sp$NAME_2 %in% "New York",]
## Make raster
r <- gt_make_raster_from_polygon(polygon    = ny_sp,
zoom       = 12,
google_key = google_key)
r
